{"version":3,"file":"downgrade_module.js","sourceRoot":"","sources":["../../../../../../packages/upgrade/static/src/static/downgrade_module.ts"],"names":[],"mappings":";;;;;;;;;;;AASA,OAAO,EAAC,eAAe,EAAC,MAAM,2BAA2B,CAAC;AAE1D,OAAO,KAAK,OAAO,MAAM,oBAAoB,CAAC;AAC9C,OAAO,EAAC,SAAS,EAAE,YAAY,EAAE,eAAe,EAAE,mBAAmB,EAAC,MAAM,qBAAqB,CAAC;AAClG,OAAO,EAAgB,UAAU,EAAC,MAAM,gBAAgB,CAAC;AAEzD,OAAO,EAAC,iBAAiB,EAAE,kBAAkB,EAAC,MAAM,sBAAsB,CAAC;AAC3E,OAAO,EAAC,iBAAiB,EAAC,MAAM,QAAQ,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuFzC,MAAM,UAAU,eAAe,CAC3B,0BAC+D;;IACjE,MAAM,gBAAgB,GAAG,mBAAmB,GAAG,OAAO,CAAC;;IACvD,MAAM,WAAW,GAAG,UAAU,CAAC,0BAA0B,CAAC,CAAC,CAAC;QACxD,0BAA0B,CAAC,CAAC;QAC5B,CAAC,cAAgC,EAAE,EAAE,CACjC,eAAe,CAAC,cAAc,CAAC,CAAC,sBAAsB,CAAC,0BAA0B,CAAC,CAAC;;IAE3F,IAAI,QAAQ,CAAW;;IAGvB,OAAO,CAAC,MAAM,CAAC,gBAAgB,EAAE,EAAE,CAAC;SAC/B,OAAO,CACJ,YAAY,EACZ,GAAG,EAAE;QACH,IAAI,CAAC,QAAQ,EAAE;YACb,MAAM,IAAI,KAAK,CACX,4EAA4E,CAAC,CAAC;SACnF;QACD,OAAO,QAAQ,CAAC;KACjB,CAAC;SACL,OAAO,CAAC,eAAe,EAAE;QACxB,SAAS;QACT,CAAC,SAAmC,EAAE,EAAE;YACtC,kBAAkB,CAAC,SAAS,CAAC,CAAC;;YAC9B,MAAM,MAAM,GAAkB;gBAC5B,WAAW,EAAE,IAAI;gBACjB,OAAO,EAAE,WAAW,CAAC,iBAAiB,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE;oBACjD,QAAQ,GAAG,MAAM,CAAC,QAAQ,GAAG,IAAI,iBAAiB,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;oBACjE,QAAQ,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;oBAExB,OAAO,QAAQ,CAAC;iBACjB,CAAC;aACH,CAAC;YACF,OAAO,MAAM,CAAC;SACf;KACF,CAAC,CAAC;IAEP,OAAO,gBAAgB,CAAC;CACzB","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injector, NgModuleFactory, NgModuleRef, StaticProvider} from '@angular/core';\nimport {platformBrowser} from '@angular/platform-browser';\n\nimport * as angular from '../common/angular1';\nimport {$INJECTOR, INJECTOR_KEY, LAZY_MODULE_REF, UPGRADE_MODULE_NAME} from '../common/constants';\nimport {LazyModuleRef, isFunction} from '../common/util';\n\nimport {angular1Providers, setTempInjectorRef} from './angular1_providers';\nimport {NgAdapterInjector} from './util';\n\n\n/**\n * @description\n *\n * A helper function for creating an AngularJS module that can bootstrap an Angular module\n * \"on-demand\" (possibly lazily) when a {@link downgradeComponent downgraded component} needs to be\n * instantiated.\n *\n * *Part of the [upgrade/static](api?query=upgrade/static) library for hybrid upgrade apps that\n * support AoT compilation.*\n *\n * It allows loading/bootstrapping the Angular part of a hybrid application lazily and not having to\n * pay the cost up-front. For example, you can have an AngularJS application that uses Angular for\n * specific routes and only instantiate the Angular modules if/when the user visits one of these\n * routes.\n *\n * The Angular module will be bootstrapped once (when requested for the first time) and the same\n * reference will be used from that point onwards.\n *\n * `downgradeModule()` requires either an `NgModuleFactory` or a function:\n * - `NgModuleFactory`: If you pass an `NgModuleFactory`, it will be used to instantiate a module\n *   using `platformBrowser`'s {@link PlatformRef#bootstrapModuleFactory bootstrapModuleFactory()}.\n * - `Function`: If you pass a function, it is expected to return a promise resolving to an\n *   `NgModuleRef`. The function is called with an array of extra {@link StaticProvider Providers}\n *   that are expected to be available from the returned `NgModuleRef`'s `Injector`.\n *\n * `downgradeModule()` returns the name of the created AngularJS wrapper module. You can use it to\n * declare a dependency in your main AngularJS module.\n *\n * {@example upgrade/static/ts/lite/module.ts region=\"basic-how-to\"}\n *\n * For more details on how to use `downgradeModule()` see\n * [Upgrading for Performance](guide/upgrade-performance).\n *\n * @usageNotes\n *\n * Apart from `UpgradeModule`, you can use the rest of the `upgrade/static` helpers as usual to\n * build a hybrid application. Note that the Angular pieces (e.g. downgraded services) will not be\n * available until the downgraded module has been bootstrapped, i.e. by instantiating a downgraded\n * component.\n *\n * <div class=\"alert is-important\">\n *\n *   You cannot use `downgradeModule()` and `UpgradeModule` in the same hybrid application.<br />\n *   Use one or the other.\n *\n * </div>\n *\n * ### Differences with `UpgradeModule`\n *\n * Besides their different API, there are two important internal differences between\n * `downgradeModule()` and `UpgradeModule` that affect the behavior of hybrid applications:\n *\n * 1. Unlike `UpgradeModule`, `downgradeModule()` does not bootstrap the main AngularJS module\n *    inside the {@link NgZone Angular zone}.\n * 2. Unlike `UpgradeModule`, `downgradeModule()` does not automatically run a\n *    [$digest()](https://docs.angularjs.org/api/ng/type/$rootScope.Scope#$digest) when changes are\n *    detected in the Angular part of the application.\n *\n * What this means is that applications using `UpgradeModule` will run change detection more\n * frequently in order to ensure that both frameworks are properly notified about possible changes.\n * This will inevitably result in more change detection runs than necessary.\n *\n * `downgradeModule()`, on the other side, does not try to tie the two change detection systems as\n * tightly, restricting the explicit change detection runs only to cases where it knows it is\n * necessary (e.g. when the inputs of a downgraded component change). This improves performance,\n * especially in change-detection-heavy applications, but leaves it up to the developer to manually\n * notify each framework as needed.\n *\n * For a more detailed discussion of the differences and their implications, see\n * [Upgrading for Performance](guide/upgrade-performance).\n *\n * <div class=\"alert is-helpful\">\n *\n *   You can manually trigger a change detection run in AngularJS using\n *   [scope.$apply(...)](https://docs.angularjs.org/api/ng/type/$rootScope.Scope#$apply) or\n *   [$rootScope.$digest()](https://docs.angularjs.org/api/ng/type/$rootScope.Scope#$digest).\n *\n *   You can manually trigger a change detection run in Angular using {@link NgZone#run\n *   ngZone.run(...)}.\n *\n * </div>\n *\n * @experimental\n */\nexport function downgradeModule<T>(\n    moduleFactoryOrBootstrapFn: NgModuleFactory<T>|\n    ((extraProviders: StaticProvider[]) => Promise<NgModuleRef<T>>)): string {\n  const LAZY_MODULE_NAME = UPGRADE_MODULE_NAME + '.lazy';\n  const bootstrapFn = isFunction(moduleFactoryOrBootstrapFn) ?\n      moduleFactoryOrBootstrapFn :\n      (extraProviders: StaticProvider[]) =>\n          platformBrowser(extraProviders).bootstrapModuleFactory(moduleFactoryOrBootstrapFn);\n\n  let injector: Injector;\n\n  // Create an ng1 module to bootstrap.\n  angular.module(LAZY_MODULE_NAME, [])\n      .factory(\n          INJECTOR_KEY,\n          () => {\n            if (!injector) {\n              throw new Error(\n                  'Trying to get the Angular injector before bootstrapping an Angular module.');\n            }\n            return injector;\n          })\n      .factory(LAZY_MODULE_REF, [\n        $INJECTOR,\n        ($injector: angular.IInjectorService) => {\n          setTempInjectorRef($injector);\n          const result: LazyModuleRef = {\n            needsNgZone: true,\n            promise: bootstrapFn(angular1Providers).then(ref => {\n              injector = result.injector = new NgAdapterInjector(ref.injector);\n              injector.get($INJECTOR);\n\n              return injector;\n            })\n          };\n          return result;\n        }\n      ]);\n\n  return LAZY_MODULE_NAME;\n}\n"]}